// KerML Grammar - Kernel Modeling Language (base for SysML v2)
// This will be incrementally expanded following TDD

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment }

line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = @{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Terminals

decimal = @{ ASCII_DIGIT+ }
fraction = @{ "." ~ decimal }
float = @{ decimal ~ fraction? | fraction }
exponent = @{ ^"e" ~ ("+" | "-")? ~ decimal }
number = @{ float ~ exponent? }

unrestricted_name = @{ "'" ~ (("\\" ~ ("'" | "\"" | "b" | "f" | "t" | "n" | "r" | "\\")) | (!"'" ~ !"\\" ~ ANY))* ~ "'" }
name = @{ identifier | unrestricted_name }

// Keywords - KerML specific, ordered by length (longest first)
keyword = @{
    "subclassifier" | "specialization" | "redefinition" | "multiplicty" | "interaction"
    | "differences" | "conjugation" | "conjugates" | "classifier" | "dependency"
    | "disjoining" | "intersects" | "inverting" | "namespace" | "nonunique"
    | "specializes" | "succession" | "predicate" | "protected" | "reference"
    | "redefines" | "standard" | "featuring" | "metaclass" | "connector"
    | "datatype" | "disjoint" | "featured" | "function" | "language"
    | "metadata" | "readonly" | "behavior" | "binding" | "comment"
    | "crosses" | "default" | "derived" | "feature" | "hastype"
    | "implies" | "inverse" | "istype" | "library" | "ordered"
    | "package" | "portion" | "private" | "public" | "struct"
    | "subsets" | "subtype" | "typing" | "abstract" | "about"
    | "alias" | "assoc" | "chains" | "class" | "composite"
    | "conjugate" | "differs" | "expr" | "false" | "filter"
    | "first" | "import" | "inout" | "locale" | "member"
    | "return" | "subset" | "unions" | "typed" | "bool"
    | "else" | "flow" | "from" | "meta" | "null" | "step"
    | "then" | "true" | "type" | "and" | "doc" | "end"
    | "for" | "inv" | "not" | "out" | "rep" | "xor"
    | "all" | "as" | "by" | "if" | "in" | "of" | "or" | "to"
}

// Identifiers  
identifier = @{ 
    unrestricted_name 
    | (!(keyword ~ !(ASCII_ALPHANUMERIC | "_")) ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*)
}

// Name that can be a keyword (used for type identifiers)
name_identifier = @{ 
    unrestricted_name 
    | ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")*
}

// Identification fragments
short_name = { "<" ~ name ~ ">" }
regular_name = { name }
identification = { (short_name ~ regular_name?) | regular_name }

// Relationship Tokens (alternative syntax)
specializes_token = @{ ":>" | "specializes" }
subsets_token = @{ ":>" | "subsets" }
references_token = @{ "::>" | "references" }
crosses_token = @{ "=>" | "crosses" }
redefines_token = @{ ":>>" | "redefines" }
typed_by_token = @{ ":" | ("typed" ~ " " ~ "by") }
conjugates_token = @{ "~" | "conjugates" }

// Enum Types
visibility_kind = @{ "protected" | "private" | "public" }
// Use negative lookahead to ensure direction kinds are complete words
// This prevents "in" from matching the start of "interface"
feature_direction_kind = @{ ("inout" | "in" | "out") ~ !(ASCII_ALPHANUMERIC | "_") }
unary_operator = @{ "+" | "-" ~ !(">" | "->") | "not" | "~" }
classification_test_operator = @{ "@@" | "hastype" | "istype" | "@" }
equality_operator = @{ "!==" | "!=" | "===" | "==" }
import_kind = @{ "::*::**" | "::**" | "::*" }
relational_operator = @{ "<=" | "<" | ">=" | ">" }

// Common Fragments

abstract_marker = { "abstract" }
visibility = { visibility_kind }
readonly = { "readonly" }
derived = { "derived" }
end_marker = { "end" }
variable_marker = { "variation" | "var" }
feature_modifier = { readonly | derived | end_marker | variable_marker }
sufficient = { "all" }
standard_marker = { "standard" }
import_all = { "all" }

multiplicity_properties = {
    ("ordered" ~ "nonunique"?)
    | ("nonunique" ~ "ordered"?)
}

enum_type = {
    visibility_kind
    | feature_direction_kind
    | unary_operator
    | classification_test_operator
    | equality_operator
    | import_kind
    | relational_operator
}

// Union Types

// InlineExpression - union of expression types that can appear inline
inline_expression = {
    operator_expression  // Top-level expression that includes all operators and sub-expressions
}

// NonOwnerType - union of non-owning relationship types
// Note: annotation must come before membership since membership has all optional fields
non_owner_type = {
    annotation
    | membership
}

// Annotations

// Helper for string literals
string_value = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }

// Helper for character literals
char_value = @{ "'" ~ (!"'" ~ ANY) ~ "'" }

// Annotation - references another element
annotation = {
    element_reference
}

comment_annotation = { "comment" ~ identification? ~ ("locale" ~ string_value)? ~ ("about" ~ element_reference ~ ("," ~ element_reference)*)? ~ (block_comment | ";")? }

documentation = { 
    "doc" ~ identification? ~ ("locale" ~ string_value)? ~ (block_comment | ";")? }


// Textual representation with language
textual_representation = {
    ("rep" ~ identification?)? ~ "language" ~ string_value ~ block_comment? ~ ";"?
}

// Owned Annotations

owned_annotation = {
    annotating_element
}

annotating_element = {
    comment_annotation
    | documentation
    | textual_representation
    | metadata_feature
    | ignored_block_comment
}

ignored_block_comment = _{ block_comment }

// Prefix Metadata Annotation
prefix_metadata_annotation = {
    "#" ~ metadata_feature
}

// Elements

// Base element with optional names
element = {
    ("<" ~ identifier ~ ">")? ~ identifier?
}

// Namespace contains other elements
namespace = {
    prefix_metadata? ~
    "namespace" ~ identification? ~
    namespace_body
}

// Namespace Body
namespace_body = {
    ";" | ("{" ~ namespace_body_elements ~ "}")
}

// Namespace body elements already defined below at line ~690

// Non-Feature Member
non_feature_member = {
    visibility_kind? ~ non_feature_element
}

// Namespace Feature Member
namespace_feature_member = {
    visibility_kind? ~ feature_element
}

// Relationship Member
relationship_member = {
    visibility_kind? ~ relationship_element
}

// Annotating Member
annotating_member = {
    visibility_kind? ~ annotating_element
}

// Alias Member
alias_member = {
    visibility_kind? ~
    "alias" ~ identification? ~
    "for" ~ element_reference ~
    relationship_body
}

// Prefix Metadata (shorthand for metadata annotations)
prefix_metadata = {
    prefix_metadata_annotation+
}

// Namespace Elements - Union Types

// RelationshipElement - union of relationship types
relationship_element = {
    dependency
    | specialization
    | conjugation
    | feature_typing
    | subclassification
    | disjoining
    | feature_inverting
    | subsetting
    | redefinition
    | type_featuring
}

// NonFeatureElement - union of namespace types
non_feature_element = {
    namespace
    | package
    | library_package
    | multiplicity
    | type_def
    | classifier
    | class
    | structure
    | metaclass
    | data_type
    | association
    | association_structure
    | interaction
    | behavior
    | function
    | predicate
}

// FeatureElement - union of feature types
feature_element = {
    end_feature
    | feature
    | step
    | expression
    | boolean_expression
    | invariant
    | connector
    | binding_connector
    | succession
    | item_flow
    | succession_item_flow
}

// Type Relationships - relationships specific to types
type_relationship = {
    unioning
    | differencing
    | disjoining
    | intersecting
}

// Heritage - inheritance-based relationships for types
heritage = {
    specialization
    | reference_subsetting
    | subsetting
    | redefinition
    | cross_subsetting
    | conjugation
}

// Feature Relationships - relationships specific to features
feature_relationship = {
    type_relationship
    | feature_typing
    | feature_chaining
    | feature_inverting
    | type_featuring
}

// Multiplicity Bounds - the [lower..upper] syntax
multiplicity_bounds = {
    "[" ~ multiplicity_bounds_range ~ "]"
}

multiplicity_bounds_range = {
    multiplicity_bound ~ (".." ~ multiplicity_bound)?
}

multiplicity_bound = {
    inline_expression | number | "*"
}

// Type extends Namespace
type_def = {
    prefix_metadata? ~
    abstract_marker? ~
    "type" ~ identification? ~
    "all"? ~
    (heritage | type_relationship | feature_relationship)* ~
    multiplicity? ~
    ("ordered" | "nonunique")* ~
    namespace_body
}

// Classifier extends Type
classifier = {
    prefix_metadata? ~
    abstract_marker? ~
    "classifier" ~ identification? ~
    "all"? ~
    (heritage | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// DataType extends Classifier
data_type = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "datatype" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// Class extends Classifier
class = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "class" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// Structure extends Class
structure = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "struct" ~ identification? ~
    "all"? ~
    multiplicity_bounds? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    namespace_body
}

// Behavior extends Class
behavior = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "behavior" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// Association extends Classifier and Relationship
association = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "assoc" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// AssociationStructure extends Association and Structure
association_structure = {
    prefix_metadata? ~
    abstract_marker? ~
    "assoc" ~ "struct" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// Metaclass extends Structure
metaclass = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "metaclass" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// Function extends Behavior
function = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "function" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    result_expression_membership? ~
    namespace_body
}

// Predicate extends Function
predicate = {
    prefix_metadata? ~
    abstract_marker? ~
    "predicate" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    result_expression_membership? ~
    namespace_body
}

// Interaction extends Association and Behavior
interaction = {
    prefix_metadata? ~
    visibility_kind? ~
    abstract_marker? ~
    "interaction" ~ identification? ~
    "all"? ~
    (heritage | inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    namespace_body
}

// Feature extends Type
feature = {
    prefix_metadata? ~
    visibility_kind? ~
    feature_direction_kind? ~
    ("abstract"| "composite" | "portion" | "member" | readonly | derived | end_marker | variable_marker)* ~
    "feature" ~ "all"? ~ identification? ~
    feature_specialization_part? ~
    ("ordered" | "nonunique")* ~
    feature_value? ~
    namespace_body
}

// End feature with identification and multiplicity: end <id> [mult] feature ... or end [mult] feature <id> ...
end_feature = {
    prefix_metadata? ~
    end_marker ~ (
        identification ~ multiplicity_bounds ~ feature_specialization_part? ~ "feature" ~ identification? ~ feature_specialization_part?  // end name [mult] relationships? feature ...
        | identification ~ feature_specialization_part ~ "feature" ~ identification? ~ feature_specialization_part?                       // end name relationships feature ...
        | multiplicity_bounds ~ "feature" ~ identification? ~ feature_specialization_part?                                                // end [mult] feature name ...
    ) ~
    feature_value? ~
    namespace_body
}

feature_specialization_part = {
    (heritage | type_relationship | feature_relationship)+ ~ multiplicity_part ~ (heritage | type_relationship | feature_relationship)*
    | (heritage | type_relationship | feature_relationship)+
    | multiplicity_part ~ (heritage | type_relationship | feature_relationship)*
    | multiplicity_part
}

multiplicity_part = {
    multiplicity_bounds ~ multiplicity_properties?
    | multiplicity_properties
}

// MetadataFeature extends Feature and AnnotatingElement
metadata_feature = {
    "metadata" ~
    feature_direction_kind? ~
    ("abstract" | "composite" | "portion")? ~
    feature_modifier? ~
    prefix_metadata? ~
    abstract_marker? ~
    "type" ~ identification? ~
    "all"? ~
    (inheritance | type_relationship | feature_relationship)* ~
    multiplicity? ~
    ("about" ~ annotation ~ ("," ~ annotation)*)? ~
    namespace_body
}

// Multiplicity extends Feature
multiplicity = {
    prefix_metadata? ~
    feature_direction_kind? ~
    ("abstract"| "composite" | "portion" | "member" | readonly | derived | end_marker | variable_marker)* ~
    ("multiplicity" | "feature") ~ identification? ~
    feature_specialization_part? ~
    feature_value? ~
    namespace_body
}

// MultiplicityRange extends Multiplicity
multiplicity_range = {
    multiplicity ~
    owning_membership?
}

// ItemFeature extends Feature
item_feature = {
    feature
}

// Step extends Feature
step = {
    prefix_metadata? ~
    feature_direction_kind? ~
    ("abstract" | "composite" | "portion")? ~
    feature_modifier? ~
    "step" ~ identification? ~
    feature_specialization_part? ~
    feature_value? ~
    membership? ~
    owning_membership? ~
    namespace_body
}

// Connector extends Feature and Relationship
// Connector endpoint definition for from/to clauses
connector_endpoint = {
    multiplicity_bounds? ~ (owned_feature_chain | identification) ~ feature_specialization_part?
}

connector = {
    prefix_metadata? ~
    feature_direction_kind? ~
    ("abstract" | "composite" | "portion")? ~
    feature_modifier? ~
    "connector" ~ "all"? ~ multiplicity_bounds? ~ identification? ~
    feature_typing? ~
    ("from" ~ connector_endpoint)? ~
    ("to" ~ connector_endpoint)? ~
    ("ordered" | "nonunique")* ~
    feature_value? ~
    end_feature_membership* ~
    namespace_body
}

// ItemFlowEnd extends Feature
item_flow_end = {
    feature
}

// Succession extends Connector
succession = {
    prefix_metadata? ~
    feature_direction_kind? ~
    ("abstract" | "composite" | "portion")? ~
    feature_modifier? ~
    "succession" ~ "all"? ~ identification? ~
    multiplicity_bounds? ~
    feature_typing? ~
    (
        ("first" ~ multiplicity_bounds? ~ (owned_feature_chain | element_reference))
        | (multiplicity_bounds? ~ (owned_feature_chain | element_reference))
    )? ~
    ("then" ~ multiplicity_bounds? ~ (owned_feature_chain | element_reference))? ~
    ("ordered" | "nonunique")* ~
    feature_value? ~
    membership? ~
    owning_membership? ~
    end_feature_membership* ~
    namespace_body
}

// BindingConnector extends Connector
binding_connector = {
    prefix_metadata? ~
    feature_direction_kind? ~
    ("abstract" | "composite" | "portion")? ~
    feature_modifier? ~
    "binding" ~ (
        owned_feature_chain ~ ("=" ~ multiplicity_bounds? ~ (owned_feature_chain | element_reference))
        | identification? ~ multiplicity_bounds? ~
          (
              feature_typing
              | (("featuring" | "of") ~ multiplicity_bounds? ~ (owned_feature_chain | element_reference))
              | (multiplicity_bounds? ~ (owned_feature_chain | element_reference))
          )? ~
          ("=" ~ multiplicity_bounds? ~ (owned_feature_chain | element_reference))?
    ) ~
    ("ordered" | "nonunique")* ~
    feature_value? ~
    membership? ~
    owning_membership? ~
    end_feature_membership* ~
    namespace_body
}

// Expression extends Step
expression = {
    prefix_metadata? ~
    visibility_kind? ~
    feature_direction_kind? ~
    ("abstract" | "composite" | "portion")? ~
    feature_modifier? ~
    "expr" ~ identification? ~
    feature_specialization_part? ~
    feature_value? ~
    membership? ~
    owning_membership? ~
    result_expression_membership? ~
    namespace_body
}

// ItemFlow extends Connector and Step
item_flow = {
    ("abstract" | "composite" | "portion")? ~
    "flow" ~ (
        "connector" ~ identification? ~
        feature_specialization_part? ~
        ("from" ~ connector_endpoint)? ~
        ("to" ~ connector_endpoint)? ~
        ("ordered" | "nonunique")* ~
        feature_value? ~
        end_feature_membership* ~
        (namespace_body | ";")
        | identification ~ feature_specialization_part? ~
          ("ordered" | "nonunique")* ~
          feature_value? ~
          end_feature_membership* ~
          (namespace_body | ";")
    )
}

// SuccessionItemFlow extends ItemFlow and Succession
succession_item_flow = {
    "succession" ~ "flow" ~ ("abstract" | "composite" | "portion")? ~
    "flow" ~ "connector" ~ identification? ~
    feature_specialization_part? ~
    ("from" ~ connector_endpoint)? ~
    ("to" ~ connector_endpoint)? ~
    ("ordered" | "nonunique")* ~
    feature_value? ~
    end_feature_membership* ~
    (namespace_body | ";")
}

// BooleanExpression extends Expression
boolean_expression = {
    expression
}

// Invariant extends BooleanExpression
invariant = {
    prefix_metadata? ~
    "inv" ~ "not"? ~ identification? ~
    (namespace_body | ("{" ~ operator_expression ~ "}"))
}

// Package extends Namespace
package = {
    prefix_metadata? ~
    "package" ~ identification? ~
    namespace_body
}

// LibraryPackage extends Package
library_package = {
    standard_marker?
    ~ "library"
    ~ prefix_metadata?
    ~ "package" ~ identification?
    ~ namespace_body
}

// Relationships

// Base relationship with visibility and references
relationship = {
    visibility_kind? ~
    element_reference ~
    ("::" ~ element_reference)?
}

// Inheritance - base for inheriting relationships
inheritance = {
    relationship
}

// Unioning extends Relationship
unioning = {
    "unions" ~ relationship ~ ("," ~ relationship)*
}

// Differencing extends Relationship
differencing = {
    "differs" ~ relationship
}

// Intersecting extends Relationship
intersecting = {
    "intersects" ~ relationship ~ ("," ~ relationship)*
}

// FeatureChaining extends Relationship
feature_chaining = {
    "chains" ~ ((identifier ~ ("." ~ identifier)+) | qualified_reference_chain | relationship)
}

// Specialization extends Inheritance
specialization = {
    specializes_token ~ inheritance ~ ("," ~ inheritance)*
}

// Disjoining extends Relationship
disjoining = {
    "disjoint" ~ (
        element_reference ~ "from" ~ element_reference  // disjoint a.b from c.d
        | "from" ~ relationship                          // disjoint from X
        | visibility_kind? ~ element_reference            // disjoint Type1 or disjoint private Type2
    )
}

// FeatureInverting extends Relationship
feature_inverting = {
    "inverse" ~ "of"? ~ relationship
}

// Featuring extends Relationship
featuring = {
    "featured" ~ relationship
}

// TypeFeaturing extends Featuring
type_featuring = {
    "featuring" ~ featuring
}

// FeatureTyping extends Specialization
feature_typing = {
    typed_by_token ~ (specialization | (visibility_kind? ~ element_reference)) ~ multiplicity_bounds?
}

// Subclassification extends Specialization
subclassification = {
    "subclassifier" ~ specialization
}

// Subsetting extends Specialization
subsetting = {
    subsets_token ~ inheritance ~ ("," ~ inheritance)*
}

// Conjugation extends Inheritance
conjugation = {
    conjugates_token ~ inheritance
}

// Redefinition extends Subsetting
redefinition = {
    redefines_token ~ inheritance ~ ("," ~ inheritance)*
}

// ReferenceSubsetting extends Subsetting
reference_subsetting = {
    references_token ~ inheritance
}

// CrossSubsetting extends Subsetting
cross_subsetting = {
    crosses_token ~ inheritance
}

// Dependency extends Relationship
dependency = {
    prefix_metadata_annotation* ~
    "dependency" ~ (identification? ~ "from")? ~
    element_reference ~ ("," ~ element_reference)* ~ "to" ~
    element_reference ~ ("," ~ element_reference)* ~
    relationship_body
}

// Import extends Relationship

// Import prefix fragment
import_prefix = {
    visibility_kind? ~ "import" ~ import_all?
}

// Imported reference with namespace and recursive flags
imported_reference = {
    element_reference ~ import_kind?
}

// Import with optional filter package
import = {
    import_prefix ~
    imported_reference ~
    filter_package? ~
    relationship_body
}

// Filter Package
filter_package = {
    filter_package_member+
}

// Filter Package Member
filter_package_member = {
    "[" ~ owned_expression ~ "]"
}

// Owned Expression (forward reference - define later with expressions)
owned_expression = {
    expression
}

// MembershipImport extends Import
membership_import = {
    import
}

// NamespaceImport extends Import
namespace_import = {
    import
}

// Membership extends Relationship
membership = {
    visibility_kind? ~
    "alias"? ~
    element_reference?
}

// OwningMembership extends Membership
owning_membership = {
    inline_expression | membership
}

// FeatureValue extends OwningMembership
feature_value = {
    ("=" | ":=" | "default") ~
    owning_membership
}

// ElementFilterMembership extends OwningMembership
element_filter_membership = {
    "filter" ~ owning_membership
}

// FeatureMembership extends Featuring and OwningMembership
feature_membership = {
    featuring ~
    owning_membership
}

// EndFeatureMembership extends FeatureMembership
end_feature_membership = {
    "end" ~ (
        typed_feature_member
        | feature_membership
    )
}

// ParameterMembership extends FeatureMembership
// Simplified: direction identifier : type[mult] ;
// Or: direction featuretype identifier[mult] { body }
parameter_membership = {
    feature_direction_kind ~ (
        name_identifier ~ identifier ~ parameter_specialization_part? ~ feature_value?  // type + name
        | identifier ~ parameter_specialization_part? ~ feature_value?  // just name
        | name_identifier ~ parameter_specialization_part ~ feature_value?  // type + relationships
        | parameter_specialization_part ~ feature_value?  // just relationships
    ) ~ (namespace_body | ";")
}

parameter_specialization_part = {
    (feature_typing | heritage)+ ~ multiplicity_part ~ (feature_typing | heritage)*
    | (feature_typing | heritage)+
    | multiplicity_part ~ (feature_typing | heritage)*
    | multiplicity_part
}

// ResultExpressionMembership extends FeatureMembership
result_expression_membership = {
    "return" ~ feature_membership
}

// ReturnParameterMembership extends ParameterMembership
// Simplified: return : type[mult] default expr ;
return_parameter_membership = {
    "return" ~ "feature"? ~ (
        identifier ~ parameter_specialization_part? ~ (("=" | "default") ~ inline_expression)?
        | parameter_specialization_part ~ (("=" | "default") ~ inline_expression)?
    ) ~ (namespace_body | ";")
}

// References

// QualifiedReferenceChain - name::name::name or name.name.name pattern
qualified_reference_chain = {
    identifier ~ ("::" ~ identifier | "." ~ identifier)*
}

// ElementReference - base reference type
element_reference = {
    qualified_reference_chain
}

// NamespaceReference extends ElementReference
namespace_reference = {
    qualified_reference_chain
}

// TypeReference extends NamespaceReference
type_reference = {
    qualified_reference_chain
}

// ClassifierReference extends TypeReference
classifier_reference = {
    qualified_reference_chain
}

// FeatureReference extends TypeReference
feature_reference = {
    qualified_reference_chain
}

// MetaclassReference extends ClassifierReference
metaclass_reference = {
    qualified_reference_chain
}

// MembershipReference extends ElementReference
membership_reference = {
    qualified_reference_chain
}

// Literal Expressions

literal_boolean = {
    "false" | "true"
}

literal_string = {
    string_value
}

literal_char = {
    char_value
}

literal_number = {
    number
}

literal_infinity = {
    "*"
}

literal_expression = {
    literal_boolean
    | literal_string
    | literal_char
    | literal_number
    | literal_infinity
}

// Null Expression
null_expression = {
    "null" | ("(" ~ ")")
}

// Complex Expression Types (placeholders for full implementation)

// OperatorExpression - base for operator-based expressions with proper precedence
operator_expression = {
    conditional_expression
}

// Conditional Expression (if-then-else ternary)
conditional_expression = {
    "if" ~ null_coalescing_expression ~ "?" ~ operator_expression ~ "else" ~ operator_expression
    | null_coalescing_expression
}

// Null coalescing (default) expression
null_coalescing_expression = {
    implies_expression ~ ("??" ~ implies_expression)*
}

// Implies expression (logical implication)
implies_expression = {
    or_expression ~ ("implies" ~ or_expression)*
}

// Logical OR expressions
or_expression = {
    xor_expression ~ (("or" | "|") ~ xor_expression)*
}

// Logical XOR expressions
xor_expression = {
    and_expression ~ ("xor" ~ and_expression)*
}

// Logical AND expressions
and_expression = {
    equality_expression ~ (("and" | "&") ~ equality_expression)*
}

// Equality Expressions
equality_expression = {
    classification_expression ~ (equality_operator ~ classification_expression)*
}

// Classification Expressions (as/istype/hastype operators for type operations)
classification_expression = {
    relational_expression ~ ((as_operator | classification_test_operator) ~ type_reference)?
}

as_operator = @{ "as" ~ !(ASCII_ALPHANUMERIC | "_") }

// Relational Expressions
relational_expression = {
    range_expression ~ (relational_operator ~ range_expression)*
}

// Range Expressions (handles .. operator)
range_expression = {
    additive_expression ~ (".." ~ additive_expression)?
}

// Additive Expressions
additive_expression = {
    multiplicative_expression ~ (additive_operator ~ multiplicative_expression)*
}

additive_operator = {
    "+" | "-"
}

// Multiplicative Expressions
multiplicative_expression = {
    exponentiation_expression ~ (multiplicative_operator ~ exponentiation_expression)*
}

multiplicative_operator = {
    "*" | "/" | "%"
}

// Exponentiation Expressions
exponentiation_expression = {
    unary_expression ~ (exponentiation_operator ~ exponentiation_expression)?
}

exponentiation_operator = {
    "**" | "^"
}

// Unary Expressions
unary_expression = {
    unary_operator ~ collect_operator_expression
    | collect_operator_expression
}

// Collect Operator Expressions (-> for collection operations, . for feature chaining, # for indexing)
collect_operator_expression = {
    primary_expression ~ (("." ~ identifier) | (arrow_operator ~ identifier ~ collect_operation_args?) | ("#" ~ "(" ~ operator_expression ~ ("," ~ operator_expression)* ~ ")"))*
}

arrow_operator = @{ "->" }

collect_operation_args = {
    "{" ~ "in" ~ name_identifier ~ feature_typing ~ ";" ~ operator_expression ~ "}"
    | "{" ~ parameter_membership+ ~ operator_expression ~ "}"
    | "{" ~ operator_expression ~ "}"
    | "(" ~ (operator_expression ~ ("," ~ operator_expression)*)? ~ ")"
    | operator_expression
}

// Primary Expressions
primary_expression = {
    "(" ~ operator_expression ~ ("," ~ operator_expression)* ~ ")"
    | invocation_primary
    | feature_reference_creation
    | literal_expression
    | null_expression
    | feature_reference_expression
}

feature_reference_creation = {
    "new" ~ qualified_reference_chain ~ "(" ~ (operator_expression ~ ("," ~ operator_expression)*)? ~ ")"
}

invocation_primary = {
    qualified_reference_chain ~ "(" ~ (operator_expression ~ ("," ~ operator_expression)*)? ~ ")"
}

// InvocationExpression - now handled within operator_expression hierarchy
invocation_expression = {
    operator_expression
}

// FeatureChainExpression - now handled within operator_expression hierarchy
feature_chain_expression = {
    operator_expression
}

// IndexExpression - array/collection indexing (e.g., arr[0])
index_expression = {
    // Placeholder: Will be expanded with indexing syntax
    operator_expression ~ ("[" ~ operator_expression ~ "]")*
}

// CollectExpression - collection operation
collect_expression = {
    // Placeholder: Will be expanded with collection syntax
    operator_expression
}

// SelectExpression - filtering operation
select_expression = {
    // Placeholder: Will be expanded with selection syntax
    operator_expression
}

// Metadata and Feature Typing

metadata_typing = {
    metaclass_reference
}

owned_feature_typing = {
    type_reference | owned_feature_chain
}

// Classification Expressions

metadata_reference = {
    element_reference
}

type_reference_member = {
    type_reference_feature
}

type_result_member = {
    type_reference_feature
}

type_reference_feature = {
    reference_typing
}

reference_typing = {
    type_reference
}

// Self Reference Expressions

self_reference_expression = {
    self_reference_member
}

self_reference_member = {
    empty_feature
}

empty_feature = {
    // Empty production - represents implicit self reference
    ""
}

// Primary Expressions

function_reference_expression = {
    function_reference_member
}

function_reference_member = {
    function_reference
}

function_reference = {
    reference_typing
}

feature_chain_member = {
    feature_reference | owned_feature_chain
}

// Invocation Expressions

owned_feature_chain = {
    identifier ~ ("." ~ identifier)+
}

feature_chaining_expr = {
    feature_reference
}

feature_chain_prefix = {
    (feature_chaining_expr ~ ".")+ ~ feature_chaining_expr ~ "."
}

owned_feature_chaining = {
    feature_reference
}

// Feature Reference Expressions

feature_reference_expression = {
    feature_reference_member
}

feature_reference_member = {
    feature_reference
}

// Metadata Access Expressions

metadata_access_expression = {
    element_reference ~ "." ~ "metadata"
}

// Relationship Body Fragments

relationship_body = {
    ";" | ("{" ~ relationship_owned_elements ~ "}")
}

relationship_owned_elements = {
    relationship_owned_element*
}

relationship_owned_element = {
    owned_annotation
    | feature_element
    | non_feature_element
    | relationship_element
}

// Namespace Body Elements

namespace_body_elements = {
    namespace_body_element*
}

namespace_body_element = {
    import
    | alias_member
    | annotating_member
    | parameter_membership
    | return_parameter_membership
    | end_feature_membership
    | namespace_feature_member
    | non_feature_member
    | typed_feature_member
    | subset_member
    | shorthand_feature_member
    | relationship_member
    | operator_expression
}

// Shorthand feature member without 'feature' keyword
shorthand_feature_member = {
    visibility_kind? ~
    (
        identification ~ feature_typing? ~ (heritage | type_relationship | feature_relationship)* ~ feature_value?
        | (heritage | type_relationship | feature_relationship)+ ~ feature_value?
    ) ~
    ";"
}

// Subset member shorthand: subset x.y subsets a.b;
subset_member = {
    "subset" ~ qualified_reference_chain ~ (heritage | type_relationship | feature_relationship)+ ~ ";"
}

// Typed feature shorthand: <type> <name>? <relationships>* <mult>? <body>
// e.g., "bool monitoredOccurrence[1] { }" or "protected bool redefines x {}"
// Allows multiplicity before or after relationships
typed_feature_member = {
    visibility_kind? ~
    name_identifier ~ // Type reference (can be keyword like "bool")
    identification? ~ // Optional feature name
    (
        (heritage | type_relationship | feature_relationship)+ ~ multiplicity_bounds? ~ (heritage | type_relationship | feature_relationship)*
        | (heritage | type_relationship | feature_relationship)+
        | multiplicity_bounds ~ (heritage | type_relationship | feature_relationship)*
        | multiplicity_bounds
    )? ~
    feature_value? ~
    namespace_body
}

// Root Namespace Entry Point

root_namespace = {
    SOI ~ namespace_body_elements ~ EOI
}

// Entry point for parsing KerML files
file = { SOI ~ namespace_element* ~ EOI }

namespace_element = {
    package
    | library_package
    | import
    | alias_member
    | annotating_member
    | namespace_feature_member
    | non_feature_member
    | relationship_member
}
