// SysMLv2 Grammar - Minimal Starting Point
// This will be incrementally expanded following TDD

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ line_comment | block_comment }

line_comment = { "//" ~ (!"\n" ~ ANY)* }
block_comment = { "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Keywords - ordered by length (longest first) to avoid prefix matching issues
keyword = @{
    "verification" | "stakeholder" | "specializes" | "requirement" | "redefines" 
    | "references" | "individual" | "constraint" | "connection" | "allocation"
    | "dependency" | "occurrence" | "rendering" | "viewpoint" | "variation" 
    | "attribute" | "interface" | "objective" | "nonunique" | "succession" 
    | "terminate" | "transition" | "timeslice" | "protected" | "standard"
    | "readonly" | "metadata" | "language" | "snapshot" | "parallel"
    | "allocate" | "analysis" | "abstract" | "library" | "require" 
    | "conjugate" | "perform" | "exhibit" | "include" | "satisfy" | "binding" 
    | "crosses" | "message" | "package" | "private" | "variant"
    | "concern" | "connect" | "default" | "defined" | "derived" 
    | "subject" | "ordered" | "hastype" | "istype" | "implies" 
    | "comment" | "subsets" | "render" | "expose" | "decide" 
    | "import" | "return" | "action" | "accept" | "assert" 
    | "assign" | "assume" | "locale" | "verify" | "event" 
    | "entry" | "false" | "frame" | "about" | "actor" 
    | "after" | "alias" | "while" | "until" | "first" 
    | "merge" | "inout" | "public" | "filter" | "state"
    | "port" | "case" | "calc" | "send" | "then" | "flow" 
    | "fork" | "from" | "join" | "loop" | "part" | "true" 
    | "view" | "bind" | "else" | "enum" | "item" | "meta" 
    | "null" | "when" | "exit" | "life"
    | "def" | "doc" | "end" | "for" | "not" | "ref" | "rep" 
    | "use" | "via" | "xor" | "all" | "and" | "out"
    | "to" | "as" | "at" | "by" | "do" | "if" | "in" | "of" | "or"
}

// Identifiers
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// Tokens

defined_by_token = @{ ":" | ("defined" ~ " " ~ "by") }

// Enums

portion_kind = @{ "timeslice" | "snapshot" }
requirement_constraint_kind = @{ "assume" | "require" }

// Fragments (Markers)

variation_marker = { "variation" }
individual_marker = { "individual" }
abstract_marker = { "abstract" }
standard_marker = { "standard" }

// Visibility

visibility = @{ "public" | "private" | "protected" }

// Control Nodes - extends ActionUsage

control_node = {
    merge_node
    | decision_node
    | join_node
    | fork_node
}

control_node_prefix = {
    ref_prefix ~ individual_marker? ~ portion_kind? ~ usage_extension_keyword*
}

merge_node = {
    control_node_prefix ~ "merge" ~ usage_declaration? ~ action_body
}

decision_node = {
    control_node_prefix ~ "decide" ~ usage_declaration? ~ action_body
}

join_node = {
    control_node_prefix ~ "join" ~ usage_declaration? ~ action_body
}

fork_node = {
    control_node_prefix ~ "fork" ~ usage_declaration? ~ action_body
}

// State Subaction Membership - extends FeatureMembership

state_subaction_kind = { "entry" | "exit" | "do" }
state_subaction_membership = { state_subaction_kind ~ identifier ~ ";" }

// Transition Feature Membership - extends FeatureMembership

transition_feature_kind = { "accept" | "if" | "do" }
transition_feature_membership = { transition_feature_kind ~ identifier ~ ";" }

// Parameter Memberships - extends ParameterMembership

subject_membership = { "subject" ~ identifier ~ ";" }
actor_membership = { "actor" ~ identifier ~ ";" }
stakeholder_membership = { "stakeholder" ~ identifier ~ ";" }

// Feature Memberships

objective_membership = { "objective" ~ identifier ~ ";" }
view_rendering_membership = { "render" ~ identifier ~ ";" }

// Succession and Expose

// Succession keyword
succession_keyword = { "succession" }

succession_as_usage = {
    usage_prefix
    ~ (succession_keyword ~ usage_declaration?)?
    ~ "first"
    ~ connector_end_member
    ~ "then"
    ~ connector_end_member
    ~ definition_body
}

expose_prefix = { visibility? ~ "expose" }

expose = {
    expose_prefix ~ imported_reference ~ filter_package? ~ relationship_body
}

membership_expose = { "expose" ~ identifier ~ "::" ~ identifier ~ ";" }
namespace_expose = { "expose" ~ identifier ~ "::*" ~ ";" }

// Port and Conjugation

conjugated_port_reference = { "~" ~ identifier }
variant_membership = { "variant" ~ identifier ~ ";" }

// Requirement Constraint Memberships

requirement_constraint_membership = { "require" ~ identifier ~ ";" }
framed_concern_membership = { "frame" ~ identifier ~ ";" }
requirement_verification_membership = { "verify" ~ identifier ~ ";" }

// Terminate Action

terminate_action_usage = { "terminate" ~ identifier ~ ";" }

// Port Definitions and Conjugation

conjugated_port_definition = {
    occurrence_definition_prefix ~ "port" ~ "def" ~ "~" ~ definition_declaration ~ definition_body
}
port_conjugation = { "conjugate" ~ "~" ~ identifier ~ ";" }
conjugated_port_typing = { "port" ~ identifier ~ ":" ~ "~" ~ identifier ~ ";" }
life_class = { "life" ~ "class" ~ identifier ~ ";" }

// Package

package = {
    prefix_metadata?
    ~ package_declaration
    ~ package_body
}

library_package = {
    standard_marker?
    ~ "library"
    ~ prefix_metadata?
    ~ package_declaration
    ~ package_body
}

package_declaration = { "package" ~ identification? }

package_body = { ";" | ( "{" ~ package_body_items ~ "}" ) }

package_body_items = { package_body_element* }

package_body_element = {
    import
    | alias_member_element
    | element_filter_member
    | visible_annotating_member
    | usage_member
    | definition_member_element
    | relationship_member_element
    | dependency
}

usage_member = { visibility? ~ usage_element }

relationship_member_element = { visibility? ~ dependency }

element_filter_member = { visibility? ~ "filter" ~ owned_expression ~ ";" }

// Expressions
expression_body = {
    calculation_body
}

owned_expression_member = {
    owned_expression
}

owned_expression = {
    conditional_expression
}

owned_expression_reference = {
    owned_expression_member
}

// Conditional Expressions (with operator precedence)

concrete_conditional_expression = {
    "if" ~ null_coalescing_expression ~ "?" ~ owned_expression_reference ~ "else" ~ owned_expression_reference
}

conditional_expression = {
    concrete_conditional_expression
    | null_coalescing_expression
}

null_coalescing_expression = {
    implies_expression ~ ("??" ~ implies_expression_reference)*
}

// Logical Expressions

implies_expression_reference = {
    implies_expression_member
}

implies_expression_member = {
    implies_expression
}

implies_expression = {
    or_expression ~ ("implies" ~ or_expression_reference)*
}

or_expression_reference = {
    or_expression_member
}

or_expression_member = {
    or_expression
}

or_expression = {
    xor_expression ~ (
        ("|" ~ xor_expression)
        | ("or" ~ xor_expression_reference)
    )*
}

xor_expression_reference = {
    xor_expression_member
}

xor_expression_member = {
    xor_expression
}

xor_expression = {
    and_expression ~ ("xor" ~ and_expression)*
}

and_expression = {
    equality_expression ~ (
        ("&" ~ equality_expression)
        | ("and" ~ equality_expression_reference)
    )*
}

equality_expression_reference = {
    equality_expression_member
}

equality_expression_member = {
    equality_expression
}

// Equality Expressions
equality_expression = {
    classification_expression ~ (equality_operator ~ classification_expression)*
}

equality_operator = {
    "==" | "!=" | "===" | "!=="
}

// Classification Expressions
classification_expression = {
    relational_expression ~ (
        (classification_test_operator ~ type_reference_member)
        | ("as" ~ type_result_member)
    )?
    | classification_test_operator ~ type_reference_member
    | metadata_reference ~ "@@" ~ type_reference_member
    | "as" ~ type_result_member
    | metadata_reference ~ "meta" ~ type_result_member
}

classification_test_operator = {
    "hastype" | "istype" | "@"
}

type_reference_member = {
    type_reference
}

type_reference = {
    identifier
}

type_result_member = {
    type_result
}

type_result = {
    identifier
}

metadata_reference = {
    identifier
}

// Relational Expressions
relational_expression = {
    range_expression ~ (relational_operator ~ range_expression)*
}

relational_operator = {
    "<" | ">" | "<=" | ">="
}

// Range Expressions
range_expression = {
    additive_expression ~ (".." ~ additive_expression)?
}

// Arithmetic Expressions - Additive
additive_expression = {
    multiplicative_expression ~ ((additive_operator ~ multiplicative_expression)*)
}

additive_operator = {
    "+" | "-"
}

// Arithmetic Expressions - Multiplicative
multiplicative_expression = {
    exponentiation_expression ~ ((multiplicative_operator ~ exponentiation_expression)*)
}

multiplicative_operator = {
    "*" | "/" | "%"
}

// Arithmetic Expressions - Exponentiation
exponentiation_expression = {
    unary_expression ~ ((exponentiation_operator ~ exponentiation_expression)?)
}

exponentiation_operator = {
    "**" | "^"
}

// Unary Expressions
unary_expression = {
    unary_operator ~ extent_expression
    | extent_expression
}

unary_operator = {
    "+" | "-" | "~" | "not"
}

// Extent Expressions
extent_expression = {
    "all" ~ type_result_member
    | primary_expression
}

// Primary Expressions
primary_expression = {
    base_expression
    ~ ("." ~ feature_chain_member)?
    ~ (
        (
            "#" ~ "(" ~ sequence_expression ~ ")"  // indexing with #
            | "[" ~ sequence_expression ~ "]"      // indexing with []
            | "->" ~ reference_typing ~ (
                expression_body_member
                | function_reference_member
                | argument_list
            )  // invocation
            | "." ~ expression_body_member         // collect
            | ".?" ~ expression_body_member        // select
        )
        ~ ("." ~ feature_chain_member)?
    )*
}

// Base Expressions
base_expression = {
    null_expression
    | literal_expression
    | feature_reference_expression
    | "(" ~ sequence_expression ~ ")"
}

null_expression = {
    "null"
}

literal_expression = {
    literal
}

feature_reference_expression = {
    identifier
}

metadata_access_expression = {
    "metadata" ~ identifier
}

invocation_expression = {
    owned_feature_typing ~ argument_list
}

feature_chain_member = {
    identifier
}

// Sequence Expressions
sequence_expression = {
    owned_expression ~ ("," ~ owned_expression)*
}

reference_typing = {
    identifier
}

// Expression Body
body_expression = {
    expression_body
}

expression_body_member = {
    expression_body
}

function_reference_member = {
    identifier
}

argument_list = {
    "(" ~ (named_argument_list | positional_argument_list)? ~ ")"
}

positional_argument_list = {
    argument_member ~ ("," ~ argument_member)*
}

argument_member = {
    argument
}

argument = {
    argument_value
}

named_argument_list = {
    named_argument_member ~ ("," ~ named_argument_member)*
}

named_argument_member = {
    named_argument
}

named_argument = {
    parameter_redefinition ~ "=" ~ argument_value
}

parameter_redefinition = {
    feature_reference
}

argument_value = {
    owned_expression
}

// Literal values (basic support)
literal = {
    string_value
    | numeric_value
    | boolean_value
    | "null"
}

string_value = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
numeric_value = @{ "-"? ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean_value = @{ ("true" | "false") ~ !(ASCII_ALPHANUMERIC | "_") }

alias_member_element = {
    visibility?
    ~ "alias"
    ~ identification?
    ~ "for"
    ~ element_reference
    ~ relationship_body
}

definition_member_element = { visibility? ~ definition_element }

// Definition Structure

basic_definition_prefix = {
    abstract_marker
    | variation_marker
}

definition_extension_keyword = { prefix_metadata_member }

definition_prefix = {
    basic_definition_prefix? ~ definition_extension_keyword*
}

definition_suffix = {
    definition_declaration ~ definition_body
}

definition_declaration = {
    identification? ~ subclassification_part?
}

definition_body = {
    ";"
    | "{" ~ definition_body_items ~ "}"
}

definition_body_items = { definition_body_item* }

definition_body_item = {
    import
    | alias_member_element
    | visible_annotating_member
    | relationship_member_element
    | definition_member
    | variant_usage_member
    | non_occurrence_usage_member
    | empty_succession_member? ~ occurrence_usage_member
}

definition_member = {
    visibility? ~ definition_element
}

variant_usage_member = { visibility? ~ variant_membership }

non_occurrence_usage_member = { visibility? ~ non_occurrence_usage_element }

occurrence_usage_member = { visibility? ~ occurrence_usage_element }

// Empty succession for occurrence ordering
empty_succession_member = { empty_succession }

empty_succession = {
    "then" ~ multiplicity_source_end_member ~ empty_target_end_member
}

multiplicity_source_end_member = { multiplicity_source_end }

multiplicity_source_end = {
    owned_multiplicity?
}

empty_target_end_member = { empty_target_end }

empty_target_end = { "" }

// Definition and Usage Elements

definition_element = {
    package
    | library_package
    | attribute_definition
    | enumeration_definition
    | occurrence_definition
    | individual_definition
    | item_definition
    | metadata_definition
    | part_definition
    | connection_definition
    | flow_connection_definition
    | flow_definition
    | interface_definition
    | allocation_definition
    | port_definition
    | action_definition
    | calculation_definition
    | state_definition
    | constraint_definition
    | requirement_definition
    | concern_definition
    | case_definition
    | analysis_case_definition
    | verification_case_definition
    | use_case_definition
    | view_definition
    | viewpoint_definition
    | rendering_definition
    | extended_definition
}

// Placeholder definitions for each type (to be implemented incrementally)
attribute_definition = {
    definition_prefix ~ "attribute" ~ "def" ~ definition_suffix
}
enumeration_definition = {
    prefix_metadata? ~ "enum" ~ "def" ~ definition_declaration ~ enumeration_body
}
enumeration_body = {
    ";"
    | "{" ~ enumeration_items ~ "}"
}
enumeration_items = {
    (annotating_member | enumeration_usage_member)*
}
enumeration_usage_member = {
    visibility? ~ enumerated_value
}
enumerated_value = {
    prefix_metadata? ~ "enum"? ~ usage_suffix
}

// Occurrence keywords
occurrence_keyword = { "occurrence" }
occurrence_def_keyword = { occurrence_keyword ~ "def" }

// Empty multiplicity for individual definitions
empty_multiplicity_member = { empty_multiplicity }
empty_multiplicity = { "" }

// Occurrence definition prefix
occurrence_definition_prefix = {
    basic_definition_prefix?
    ~ ("individual" ~ empty_multiplicity_member)?
    ~ definition_extension_keyword*
}

occurrence_definition = {
    occurrence_definition_prefix ~ occurrence_def_keyword ~ definition_declaration ~ definition_body
}
individual_definition = {
    basic_definition_prefix?
    ~ "individual"
    ~ empty_multiplicity_member
    ~ definition_extension_keyword*
    ~ "def"
    ~ definition_declaration
    ~ definition_body
}

// Item keywords
item_keyword = { "item" }
item_def_keyword = { item_keyword ~ "def" }
item_usage_keyword = { item_keyword }

item_definition = {
    occurrence_definition_prefix ~ item_def_keyword ~ definition_declaration ~ definition_body
}

// Part keywords
part_keyword = { "part" }
part_def_keyword = { part_keyword ~ "def" }
part_usage_keyword = { part_keyword }

part_definition = {
    occurrence_definition_prefix ~ part_def_keyword ~ definition_declaration ~ definition_body
}

// Connection keywords
connection_keyword = { "connection" }
connection_def_keyword = { connection_keyword ~ "def" }
connector_keyword = { "connect" }
connection_usage_keyword = { connection_keyword }

connection_definition = {
    occurrence_definition_prefix ~ connection_def_keyword ~ definition_declaration ~ definition_body
}
flow_connection_definition = { "flow" ~ "connection" ~ "def" ~ identifier ~ ";" }

// Flow keywords
flow_keyword = { "flow" }
flow_def_keyword = { flow_keyword ~ "def" }

flow_definition = {
    occurrence_definition_prefix ~ flow_def_keyword ~ definition_declaration ~ definition_body
}

// Interface keywords
interface_keyword = { "interface" }
interface_def_keyword = { interface_keyword ~ "def" }

interface_definition = {
    occurrence_definition_prefix ~ interface_def_keyword ~ definition_declaration ~ interface_body
}

interface_body = {
    ";"
    | "{" ~ interface_body_item* ~ "}"
}

interface_body_item = {
    definition_member
    | variant_usage_member
    | interface_non_occurrence_usage_member
    | empty_succession_member? ~ interface_occurrence_usage_member
    | alias_member_element
    | import
}

interface_non_occurrence_usage_member = {
    visibility? ~ interface_non_occurrence_usage_element
}

interface_non_occurrence_usage_element = {
    reference_usage
    | attribute_usage
    | enumeration_usage
    | binding_connector_as_usage
    | succession_as_usage
}

interface_occurrence_usage_member = {
    visibility? ~ interface_occurrence_usage_element
}

interface_occurrence_usage_element = {
    default_interface_end
    | structure_usage_element
    | behavior_usage_element
}

default_interface_end = {
    "end" ~ usage_declaration? ~ usage_completion
}

// Interface Usages
interface_usage_keyword = { interface_keyword }

interface_usage = {
    occurrence_usage_prefix ~ interface_usage_keyword ~ interface_usage_declaration ~ interface_body
}

interface_usage_declaration = {
    usage_declaration? ~ connector_keyword ~ interface_part
    | interface_part
}

interface_part = {
    binary_interface_part
    | nary_interface_part
}

binary_interface_part = {
    interface_end_member ~ "to" ~ interface_end_member
}

nary_interface_part = {
    "(" ~ interface_end_member ~ "," ~ interface_end_member ~ ("," ~ interface_end_member)* ~ ")"
}

interface_end_member = {
    interface_end
}

interface_end = {
    owned_cross_multiplicity_member? ~ (identifier ~ references_keyword)? ~ owned_reference_subsetting
}

allocation_definition = {
    occurrence_definition_prefix ~ "allocation" ~ "def" ~ definition_suffix
}

port_definition = {
    occurrence_definition_prefix ~ "port" ~ "def" ~ definition_declaration ~ definition_body
}

// Action keywords
action_keyword = { "action" }
action_def_keyword = { action_keyword ~ "def" }
assign_keyword = { "assign" }
assignment_operator = @{ ":=" }

// State Keywords
state_keyword = { "state" }
state_def_keyword = { state_keyword ~ "def" }

// State Definition
state_definition = {
    occurrence_definition_prefix ~ state_def_keyword ~ definition_declaration ~ state_def_body
}

state_def_body = {
    ";"
    | parallel_marker? ~ "{" ~ state_body_part ~ "}"
}

parallel_marker = { "parallel" }

state_body_part = {
    state_body_item*
}

state_body_item = {
    import
    | alias_member_element
    | definition_member
    | variant_usage_member
    | non_occurrence_usage_member
    | empty_succession_member? ~ structure_usage_member
    | empty_succession_member? ~ behavior_usage_member ~ target_transition_usage_member*
    | transition_usage_member
    | entry_action_member ~ entry_transition_member*
    | do_action_member
    | exit_action_member
}

// State Subaction Members
entry_action_member = {
    member_prefix ~ entry_action_kind ~ state_action_usage
}

entry_action_kind = { "entry" }

do_action_member = {
    member_prefix ~ do_action_kind ~ state_action_usage
}

do_action_kind = { "do" }

exit_action_member = {
    member_prefix ~ exit_action_kind ~ state_action_usage
}

exit_action_kind = { "exit" }

entry_transition_member = {
    member_prefix ~ (guarded_target_succession | "then" ~ transition_succession) ~ ";"
}

state_action_usage = {
    "action" ~ (identifier ~ ";" | usage_declaration? ~ action_body)
    | ";"
    | qualified_name ~ ";"
}

empty_action_usage = {
    ""
}

performed_action_usage = {
    perform_action_usage_declaration
    | accept_node_declaration
    | send_node_declaration
    | assignment_node_declaration
}

transition_usage_member = {
    member_prefix ~ transition_usage
}

target_transition_usage_member = {
    member_prefix ~ target_transition_usage
}

action_definition = {
    occurrence_definition_prefix ~ action_def_keyword ~ definition_declaration ~ action_body
}

action_body = {
    ";"
    | "{" ~ action_body_item* ~ "}"
}

action_body_item = {
    import
    | alias_member_element
    | definition_member
    | variant_usage_member
    | non_occurrence_usage_member
    | empty_succession_member? ~ structure_usage_member
    | initial_node_member ~ target_succession_member*
    | empty_succession_member? ~ (behavior_usage_member | action_node_member) ~ target_succession_member*
    | guarded_succession_member
}

structure_usage_member = {
    visibility? ~ structure_usage_element
}

behavior_usage_member = {
    visibility? ~ behavior_usage_element
}

initial_node_member = {
    member_prefix ~ "first" ~ feature_reference ~ relationship_body
}

member_prefix = {
    visibility?
}

action_node_member = {
    member_prefix ~ action_node
}

// Action Nodes
action_node = {
    send_node
    | accept_node
    | assignment_node
    | if_node
    | while_loop_node
    | for_loop_node
    | terminate_node
    | control_node
}

action_node_usage_declaration = {
    action_usage_keyword ~ usage_declaration?
}

action_node_prefix = {
    occurrence_usage_prefix ~ action_node_usage_declaration?
}

// Accept Node
accept_node = {
    occurrence_usage_prefix ~ accept_node_declaration ~ action_body
}

accept_node_declaration = {
    action_node_usage_declaration? ~ "accept" ~ accept_parameter_part
}

accept_parameter_part = {
    payload_parameter_member ~ ("via" ~ node_parameter_member)?
}

payload_parameter_member = {
    payload_parameter
}

payload_parameter = {
    payload
    | identification? ~ payload_feature_specialization_part? ~ trigger_value_part
}

trigger_value_part = {
    trigger_feature_value
}

trigger_feature_value = {
    trigger_expression
}

trigger_expression = {
    time_trigger_kind ~ argument_member
    | change_trigger_kind ~ argument_expression_member
}

time_trigger_kind = {
    "at" | "after"
}

change_trigger_kind = {
    "when"
}

argument_expression_member = {
    argument_expression
}

argument_expression = {
    argument_expression_value
}

argument_expression_value = {
    owned_expression_reference
}

node_parameter_member = {
    node_parameter
}

node_parameter = {
    feature_binding
}

feature_binding = {
    owned_expression
}

empty_parameter_member = {
    empty_usage
}

// Send Node
send_node = {
    occurrence_usage_prefix ~ action_node_usage_declaration? ~ "send" ~ (
        action_body
        | (node_parameter_member ~ sender_receiver_part? | empty_parameter_member ~ sender_receiver_part) ~ action_body
    )
}

send_node_declaration = {
    action_node_usage_declaration? ~ "send" ~ node_parameter_member ~ sender_receiver_part?
}

sender_receiver_part = {
    "via" ~ node_parameter_member ~ ("to" ~ node_parameter_member)?
    | empty_parameter_member ~ "to" ~ node_parameter_member
}

// Assignment Node
assignment_node = {
    occurrence_usage_prefix ~ assignment_node_declaration ~ action_body
}

assignment_node_declaration = {
    assign_keyword ~ assignment_target_member ~ feature_chain_member ~ assignment_operator ~ node_parameter_member
    | action_keyword ~ usage_declaration? ~ assign_keyword ~ assignment_target_member ~ feature_chain_member ~ assignment_operator ~ node_parameter_member
}

assignment_target_member = {
    target_parameter
}

target_parameter = {
    (target_binding ~ ".")? ~ target_feature_member
}

target_binding = {
    target_expression
}

target_expression = {
    base_expression ~ (
        ("." ~ feature_chain_member)?
        ~ (
            "[" ~ sequence_expression ~ "]"
            | "->" ~ reference_typing ~ (expression_body_member | function_reference_member | argument_list)
            | "." ~ expression_body_member
            | ".?" ~ expression_body_member
        )
    )*
}

target_feature_member = {
    target_feature
}

target_feature = {
    target_accessed_feature_member
}

target_accessed_feature_member = {
    empty_usage
}

empty_usage = {
    ""
}

// Expression Parameter
expression_parameter_member = {
    owned_expression
}

// If Node
if_node = {
    action_node_prefix ~ "if" ~ expression_parameter_member ~ action_body_parameter_member ~ ("else" ~ (action_body_parameter_member | if_node_parameter_member))?
}

action_body_parameter_member = {
    action_body_parameter
}

action_body_parameter = {
    (action_usage_keyword ~ usage_declaration?)? ~ "{" ~ action_body_item* ~ "}"
}

if_node_parameter_member = {
    if_node
}

// While Loop Node
while_loop_node = {
    action_node_prefix ~ (
        "while" ~ expression_parameter_member
        | "loop" ~ empty_parameter_member
    ) ~ action_body_parameter_member ~ ("until" ~ expression_parameter_member ~ ";")?
}

// For Loop Node
for_loop_node = {
    action_node_prefix ~ "for" ~ for_variable_declaration_member ~ "in" ~ node_parameter_member ~ action_body_parameter_member
}

for_variable_declaration_member = {
    for_variable_declaration
}

for_variable_declaration = {
    usage_declaration
}

// Terminate Node
terminate_node = {
    occurrence_usage_prefix ~ action_node_usage_declaration? ~ "terminate" ~ (action_body | node_parameter_member ~ action_body)
}

target_succession_member = {
    member_prefix ~ action_target_succession
}

action_target_succession = {
    identifier
}

guarded_succession_member = {
    guarded_succession
}

guarded_succession = {
    !(domain_usage_keyword) ~ identifier
}

// Domain-specific usage keywords that should not be matched as guarded successions
domain_usage_keyword = { "satisfy" | "perform" | "exhibit" | "include" }

// Calculation Keywords
calculation_keyword = { "calc" }
calculation_def_keyword = { calculation_keyword ~ "def" }

// Calculation Definition
calculation_definition = {
    occurrence_definition_prefix ~ calculation_def_keyword ~ definition_declaration ~ calculation_body
}

calculation_body = {
    ";"
    | "{" ~ calculation_body_part ~ "}"
}

calculation_body_part = {
    calculation_body_item* ~ result_expression_member?
}

calculation_body_item = {
    action_body_item
    | return_parameter_member
}

return_parameter_member = {
    member_prefix ~ "return" ~ usage_element
}

result_expression_member = {
    member_prefix ~ owned_expression
}

// Requirement Keywords
requirement_keyword = { "requirement" }
requirement_def_keyword = { requirement_keyword ~ "def" }

// Requirement Definition
requirement_definition = {
    occurrence_definition_prefix ~ requirement_def_keyword ~ definition_declaration ~ requirement_body
}

requirement_body = {
    ";"
    | "{" ~ requirement_body_item* ~ "}"
}

requirement_body_item = {
    definition_body_item
    | subject_member
    | requirement_constraint_member
    | framed_concern_member
    | requirement_verification_member
    | actor_member
    | stakeholder_member
}

subject_member = {
    member_prefix ~ subject_usage
}

subject_usage = {
    "subject" ~ usage_extension_keyword* ~ usage_suffix
}

requirement_constraint_member = {
    member_prefix ~ requirement_constraint_kind ~ requirement_constraint_usage
}

requirement_constraint_usage = {
    owned_reference_subsetting ~ feature_specialization* ~ calculation_body
    | (usage_extension_keyword* ~ constraint_usage_keyword | usage_extension_keyword+)
      ~ constraint_usage_declaration ~ calculation_body
}

framed_concern_member = {
    member_prefix ~ framed_concern_kind ~ framed_concern_usage
}

framed_concern_kind = {
    "frame"
}

framed_concern_usage = {
    owned_reference_subsetting ~ feature_specialization* ~ requirement_body
    | (usage_extension_keyword* ~ concern_usage_keyword | usage_extension_keyword+)
      ~ constraint_usage_declaration ~ calculation_body
}

actor_member = {
    member_prefix ~ actor_usage
}

actor_usage = {
    "actor" ~ usage_extension_keyword* ~ usage_suffix
}

stakeholder_member = {
    member_prefix ~ stakeholder_usage
}

stakeholder_usage = {
    "stakeholder" ~ usage_extension_keyword* ~ usage_suffix
}

requirement_verification_member = {
    member_prefix ~ "verify" ~ requirement_verification_usage
}

requirement_verification_usage = {
    owned_reference_subsetting ~ feature_specialization* ~ requirement_body
    | (usage_extension_keyword* ~ requirement_usage_keyword | usage_extension_keyword+)
      ~ constraint_usage_declaration ~ requirement_body
}

// Concern Keywords
concern_keyword = { "concern" }
concern_def_keyword = { concern_keyword ~ "def" }

// Concern Definition
concern_definition = {
    occurrence_definition_prefix ~ concern_def_keyword ~ definition_declaration ~ requirement_body
}

// Case Keywords
case_keyword = { "case" }
case_def_keyword = { case_keyword ~ "def" }

// Case Definition
case_definition = {
    occurrence_definition_prefix ~ case_def_keyword ~ definition_declaration ~ case_body
}

case_body = {
    ";"
    | "{" ~ case_body_item* ~ result_expression_member? ~ "}"
}

case_body_item = {
    case_calculation_body_item
    | subject_member
    | actor_member
    | objective_member
}

case_calculation_body_item = {
    case_action_body_item
    | return_parameter_member
}

case_action_body_item = {
    behavior_usage_member
    | import
    | alias_member_element
    | definition_member
    | variant_usage_member
    | non_occurrence_usage_member
    | structure_usage_member
    | action_node_member
    | guarded_succession_member
}

objective_member = {
    member_prefix ~ "objective" ~ objective_requirement_usage
}

objective_requirement_usage = {
    usage_extension_keyword* ~ constraint_usage_declaration ~ requirement_body
}

// Analysis Case Keywords
analysis_keyword = { "analysis" }

// Analysis Case Definition
analysis_case_definition = {
    occurrence_definition_prefix ~ analysis_keyword ~ (case_def_keyword | "def") ~ definition_declaration ~ case_body
}

// Verification Case Keywords
verification_keyword = { "verification" }

// Verification Case Definition
verification_case_definition = {
    occurrence_definition_prefix ~ verification_keyword ~ (case_def_keyword | "def") ~ definition_declaration ~ case_body
}

// View Keywords
view_keyword = { "view" }
view_def_keyword = { view_keyword ~ "def" }

// View Definition
view_definition = {
    occurrence_definition_prefix ~ view_def_keyword ~ ("<" ~ identifier ~ ">")? ~ definition_declaration ~ view_definition_body
}

view_definition_body = {
    ";"
    | "{" ~ view_definition_body_item* ~ "}"
}

view_definition_body_item = {
    definition_body_item
    | element_filter_member
    | view_rendering_member
}

view_rendering_member = {
    member_prefix ~ "render" ~ view_rendering_usage
}

view_rendering_usage = {
    owned_reference_subsetting ~ feature_specialization* ~ usage_body
    | (prefix_metadata? ~ "rendering" | prefix_metadata) ~ usage_suffix
}

// Use Case Keywords
use_case_keyword = { "use" ~ "case" }
use_case_def_keyword = { use_case_keyword ~ "def" }

// Use Case Definition
use_case_definition = {
    occurrence_definition_prefix ~ use_case_def_keyword ~ definition_declaration ~ case_body
}

// Viewpoint Keywords
viewpoint_keyword = { "viewpoint" }
viewpoint_def_keyword = { viewpoint_keyword ~ "def" }

// Viewpoint Definition
viewpoint_definition = {
    occurrence_definition_prefix ~ viewpoint_def_keyword ~ definition_declaration ~ requirement_body
}

// Rendering Keywords
rendering_keyword = { "rendering" }
rendering_def_keyword = { rendering_keyword ~ "def" }

// Rendering Definition
rendering_definition = {
    occurrence_definition_prefix ~ rendering_def_keyword ~ definition_suffix
}
extended_definition = {
    basic_definition_prefix? ~ definition_extension_keyword+ ~ "def" ~ definition_suffix
}

usage_element = {
    non_occurrence_usage_element
    | occurrence_usage_element
}

// Usages

// Markers and keywords (matching KerML)
readonly = { "readonly" }
derived = { "derived" }
end_marker = { "end" }
feature_direction_kind = @{ "inout" | "in" | "out" }

ref_prefix = {
    feature_direction_kind?
    ~ basic_definition_prefix?
    ~ ("constant")?
    ~ readonly?
    ~ derived?
}

reference = { "ref" }

basic_usage_prefix = {
    ref_prefix ~ reference?
}

end_usage_prefix = {
    end_marker ~ owned_crossing_feature_member?
}

usage_extension_keyword = { prefix_metadata_member }

unextended_usage_prefix = {
    end_usage_prefix
    | basic_usage_prefix
}

owned_crossing_feature_member = { owned_crossing_feature }

owned_crossing_feature = {
    basic_usage_prefix? ~ usage_declaration
}

usage_prefix = {
    unextended_usage_prefix ~ usage_extension_keyword*
}

usage_suffix = {
    usage_declaration? ~ usage_completion
}

// Occurrence usage keyword
occurrence_usage_keyword = { occurrence_keyword }

// Occurrence usage prefix
occurrence_usage_prefix = {
    (end_usage_prefix ~ usage_extension_keyword*
    | basic_usage_prefix
      ~ individual_marker?
      ~ portion_kind?
      ~ usage_extension_keyword*)
}

usage_declaration = { feature_declaration }

usage_completion = {
    value_part? ~ usage_body
}

usage_body = { definition_body }

value_part = { feature_value }

feature_value = {
    ("="
    | ":="
    | "default" ~ ("=" | ":=")?
    )
    ~ owned_expression
}

// Reference Usages

default_reference_usage = {
    end_marker?
    ~ ref_prefix
    ~ usage_suffix
}

reference_usage = {
    (end_usage_prefix | ref_prefix)
    ~ "ref"
    ~ usage_suffix
}

variant_reference = {
    owned_reference_subsetting
    ~ feature_specialization*
    ~ usage_body
}

// Body Elements

non_occurrence_usage_element = {
    default_reference_usage
    | reference_usage
    | attribute_usage
    | enumeration_usage
    | binding_connector_as_usage
    | succession_as_usage
    | extended_usage
}

occurrence_usage_element = {
    structure_usage_element
    | behavior_usage_element
}

structure_usage_element = {
    occurrence_usage
    | individual_usage
    | portion_usage
    | event_occurrence_usage
    | item_usage
    | part_usage
    | view_usage
    | rendering_usage
    | port_usage
    | connection_usage
    | interface_usage
    | allocation_usage
    | message
    | flow_connection_usage
    | succession_flow_connection_usage
}

behavior_usage_element = {
    action_usage
    | calculation_usage
    | state_usage
    | constraint_usage
    | concern_usage
    | case_usage
    | analysis_case_usage
    | verification_case_usage
    | use_case_usage
    | viewpoint_usage
    | perform_action_usage
    | exhibit_state_usage
    | include_use_case_usage
    | assert_constraint_usage
    | satisfy_requirement_usage
    | requirement_usage
}

variant_usage_element = {
    variant_reference
    | reference_usage
    | attribute_usage
    | binding_connector_as_usage
    | succession_as_usage
    | occurrence_usage
    | individual_usage
    | portion_usage
    | event_occurrence_usage
    | item_usage
    | part_usage
    | view_usage
    | rendering_usage
    | port_usage
    | connection_usage
    | interface_usage
    | allocation_usage
    | message
    | flow_connection_usage
    | succession_flow_connection_usage
    | behavior_usage_element
}

// Placeholder usage rules (to be implemented incrementally)
attribute_usage = {
    usage_prefix ~ "attribute" ~ usage_suffix
}
enumeration_usage = {
    usage_prefix ~ "enum" ~ usage_suffix
}

// Binding connector keywords
binding_keyword = { "binding" }

binding_connector_as_usage = {
    usage_prefix
    ~ (binding_keyword ~ usage_declaration?)?
    ~ "bind"
    ~ connector_end_member
    ~ "="
    ~ connector_end_member
    ~ definition_body
}

extended_usage = {
    unextended_usage_prefix ~ usage_extension_keyword+ ~ usage_suffix
}
occurrence_usage = {
    occurrence_usage_prefix ~ occurrence_usage_keyword ~ usage_declaration? ~ usage_completion
}
individual_usage = {
    basic_usage_prefix ~ "individual" ~ usage_extension_keyword* ~ usage_declaration? ~ usage_completion
}
portion_usage = {
    basic_usage_prefix ~ ("individual")? ~ portion_kind ~ usage_extension_keyword* ~ usage_declaration? ~ usage_completion
}
event_occurrence_usage = {
    occurrence_usage_prefix ~ "event"
    ~ (owned_reference_subsetting ~ feature_specialization_part?
      | occurrence_usage_keyword ~ usage_declaration?)
    ~ usage_completion
}
item_usage = {
    occurrence_usage_prefix ~ item_usage_keyword ~ usage_declaration? ~ usage_completion
}
part_usage = {
    occurrence_usage_prefix ~ part_usage_keyword ~ usage_declaration? ~ usage_completion
}

// View Usage
view_usage_keyword = { view_keyword }

view_usage = {
    occurrence_usage_prefix ~ view_usage_keyword ~ usage_declaration? ~ value_part? ~ view_body
}

view_body = {
    ";"
    | "{" ~ view_body_item* ~ "}"
}

view_body_item = {
    definition_body_item
    | element_filter_member
    | expose
    | view_rendering_member
}

// Rendering Usage
rendering_usage_keyword = { rendering_keyword }

rendering_usage = {
    occurrence_usage_prefix ~ rendering_usage_keyword ~ usage_suffix
}

// Port keywords
port_keyword = { "port" }
port_usage_keyword = { port_keyword }

port_usage = {
    occurrence_usage_prefix ~ port_usage_keyword ~ usage_declaration? ~ usage_completion
}

// Connector elements
connector_end_member = { connector_end }

connector_end = {
    owned_cross_multiplicity_member?
    ~ (identification ~ references_keyword)?
    ~ owned_reference_subsetting
}

owned_cross_multiplicity_member = { owned_cross_multiplicity }

owned_cross_multiplicity = { owned_multiplicity }

references_keyword = { "references" }

// Connection usage and connector parts
connection_usage = {
    occurrence_usage_prefix
    ~ (connection_usage_keyword ~ usage_declaration? ~ value_part?
       ~ (connector_keyword ~ connector_part)?
      | connector_keyword ~ connector_part)
    ~ usage_body
}

connector_part = {
    binary_connector_part
    | nary_connector_part
}

binary_connector_part = {
    connector_end_member ~ "to" ~ connector_end_member
}

nary_connector_part = {
    "(" ~ connector_end_member
    ~ "," ~ connector_end_member
    ~ ("," ~ connector_end_member)*
    ~ ")"
}

empty_source_end_member = { empty_source_end }

empty_source_end = { "" }

allocation_usage = {
    occurrence_usage_prefix ~ "allocation" ~ usage_declaration? ~ usage_body
}

// Messages
message_keyword = { "message" }

message = {
    occurrence_usage_prefix ~ message_keyword ~ message_declaration ~ definition_body
}

message_declaration = {
    message_event_member ~ "to" ~ message_event_member
    | usage_declaration ~ value_part? ~ ("of" ~ payload_feature_member)? ~ ("from" ~ message_event_member ~ "to" ~ message_event_member)?
    | value_part ~ ("of" ~ payload_feature_member)? ~ ("from" ~ message_event_member ~ "to" ~ message_event_member)?
    | ("of" ~ payload_feature_member) ~ ("from" ~ message_event_member ~ "to" ~ message_event_member)?
    | "from" ~ message_event_member ~ "to" ~ message_event_member
}

// Flow Members - PayloadFeature
payload_feature_member = {
    payload_feature
}

payload_feature = {
    payload
}

payload = {
    identification? ~ payload_feature_specialization_part ~ value_part?
    | identification? ~ value_part
    | owned_feature_typing ~ owned_multiplicity?
    | owned_multiplicity ~ owned_feature_typing
}

payload_feature_specialization_part = {
    feature_specialization+ ~ multiplicity_part? ~ feature_specialization*
    | multiplicity_part ~ feature_specialization+
}

message_event_member = {
    message_event
}

message_event = {
    owned_reference_subsetting
}

// Flow Members - FlowEnd
flow_end_member = {
    flow_end
}

flow_end = {
    flow_end_subsetting? ~ flow_feature_member
}

flow_end_subsetting = {
    feature_reference ~ "."
    | feature_chain_prefix
}

feature_chain_prefix = {
    identifier ~ ("." ~ identifier)+ ~ "."
}

owned_feature_chaining = {
    identifier
}

flow_feature_member = {
    flow_feature
}

flow_feature = {
    flow_redefinition
}

flow_redefinition = {
    feature_reference
}

flow_connection_usage = { "flow" ~ identifier ~ ";" }
succession_flow_connection_usage = { "succession" ~ "flow" ~ identifier ~ ";" }

// Action Usages
action_usage_keyword = { action_keyword }

action_usage = {
    occurrence_usage_prefix ~ action_usage_keyword ~ action_usage_declaration ~ action_body
}

action_usage_declaration = {
    usage_declaration? ~ value_part?
}

perform_action_usage = {
    occurrence_usage_prefix ~ "perform" ~ perform_action_usage_declaration ~ action_body
}

perform_action_usage_declaration = {
    owned_reference_subsetting ~ feature_specialization_part? ~ value_part?
    | action_usage_keyword ~ usage_declaration? ~ value_part?
}

// Calculation Usage
calculation_usage_keyword = { calculation_keyword }

calculation_usage = {
    occurrence_usage_prefix ~ calculation_usage_keyword ~ action_usage_declaration ~ calculation_body
}

// State Usage
state_usage_keyword = { state_keyword }

state_usage = {
    occurrence_usage_prefix ~ state_usage_keyword ~ action_usage_declaration ~ state_usage_body
}

state_usage_body = {
    ";"
    | parallel_marker? ~ "{" ~ state_body_part ~ "}"
}

// Constraint Keywords
constraint_keyword = { "constraint" }
constraint_def_keyword = { constraint_keyword ~ "def" }

// Constraint Definition
constraint_definition = {
    occurrence_definition_prefix ~ constraint_def_keyword ~ definition_declaration ~ calculation_body
}

// Constraint Usage
constraint_usage_keyword = { constraint_keyword }

constraint_usage = {
    occurrence_usage_prefix ~ constraint_usage_keyword ~ constraint_usage_declaration ~ calculation_body
}

// Concern Usage
concern_usage_keyword = { "concern" }

concern_usage = {
    occurrence_usage_prefix ~ concern_usage_keyword ~ usage_declaration? ~ calculation_body
}

constraint_usage_declaration = {
    usage_declaration? ~ value_part?
}

assert_constraint_usage = {
    occurrence_usage_prefix ~ "assert" ~ "not"? ~ (
        owned_reference_subsetting ~ feature_specialization_part?
        | constraint_usage_keyword ~ constraint_usage_declaration
    ) ~ calculation_body
}

// Requirement Usage
requirement_usage_keyword = { requirement_keyword }

requirement_usage = {
    occurrence_usage_prefix ~ requirement_usage_keyword ~ constraint_usage_declaration ~ requirement_body
}

satisfy_requirement_usage = {
    occurrence_usage_prefix ~ "assert"? ~ ("not")? ~ "satisfy" ~ (
        requirement_usage_keyword ~ usage_declaration?
        | owned_reference_subsetting ~ feature_specialization_part?
    ) ~ value_part? ~ ("by" ~ satisfaction_subject_member)? ~ requirement_body
}

satisfaction_subject_member = {
    satisfaction_parameter
}

satisfaction_parameter = {
    satisfaction_feature_value
}

satisfaction_feature_value = {
    satisfaction_reference_expression
}

satisfaction_reference_expression = {
    feature_chain_member
}

// Case Usage Keywords
case_usage_keyword = { case_keyword }

// Case Usage
case_usage = {
    occurrence_usage_prefix ~ case_usage_keyword ~ action_usage_declaration ~ case_body
}

// Analysis Case Usage
analysis_case_usage = {
    occurrence_usage_prefix ~ analysis_keyword ~ action_usage_declaration ~ case_body
}

// Verification Case Usage
verification_case_usage = {
    occurrence_usage_prefix ~ verification_keyword ~ action_usage_declaration ~ case_body
}

use_case_usage = {
    occurrence_usage_prefix ~ "use" ~ "case" ~ usage_declaration? ~ usage_body
}

// Viewpoint Usage
viewpoint_usage_keyword = { viewpoint_keyword }

viewpoint_usage = {
    occurrence_usage_prefix ~ viewpoint_usage_keyword ~ constraint_usage_declaration ~ requirement_body
}

exhibit_state_usage = {
    occurrence_usage_prefix ~ "exhibit" ~ (
        state_usage_keyword ~ action_usage_declaration
        | owned_reference_subsetting ~ feature_specialization_part? ~ value_part?
    ) ~ state_usage_body
}

// Transition Usage
transition_usage_keyword = { "transition" }

transition_usage = {
    transition_usage_keyword ~ (usage_declaration? ~ "first")?
    ~ transition_source_member
    ~ empty_parameter_member
    ~ (empty_parameter_member ~ trigger_action_member)?
    ~ guard_expression_member?
    ~ effect_behavior_member?
    ~ "then" ~ transition_succession_member
    ~ action_body
}

target_transition_usage = {
    empty_parameter_member
    ~ (transition_usage_keyword
       ~ (empty_parameter_member ~ trigger_action_member)?
       ~ guard_expression_member?
       ~ effect_behavior_member?
      | empty_parameter_member ~ trigger_action_member
        ~ guard_expression_member?
        ~ effect_behavior_member?
      | guard_expression_member
        ~ effect_behavior_member?
    )?
    ~ "then" ~ transition_succession_member
    ~ action_body
}

transition_source_member = {
    feature_reference
    | owned_feature_chain
}

trigger_action_member = {
    trigger_feature_kind ~ trigger_action
}

trigger_feature_kind = { "accept" }

trigger_action = {
    accept_parameter_part
}

guard_expression_member = {
    guard_feature_kind ~ owned_expression
}

guard_feature_kind = { "if" }

effect_behavior_member = {
    effect_feature_kind ~ effect_behavior_usage
}

effect_feature_kind = { "do" }

effect_behavior_usage = {
    performed_action_usage ~ ("{" ~ action_body_item* ~ "}")?
    | empty_action_usage
}

transition_succession_member = {
    transition_succession
}

transition_succession = {
    empty_source_end_member ~ connector_end_member
}

include_use_case_usage = { "include" ~ identifier ~ ";" }

// Classifiers (reusing KerML rules with same names for compatibility)

specializes_token = @{ ":>" | "specializes" }

subclassification_part = {
    specializes_token
    ~ owned_subclassification
    ~ ("," ~ owned_subclassification)*
}

owned_subclassification = { classifier_reference }

classifier_reference = { qualified_name | identifier | quoted_name }

// Features

feature_declaration = {
    identification ~ feature_specialization_part?
    | feature_specialization_part
}

feature_specialization_part = {
    feature_specialization+ ~ multiplicity_part ~ feature_specialization*
    | feature_specialization+
    | multiplicity_part ~ feature_specialization*
    | multiplicity_part
}

multiplicity_part = {
    owned_multiplicity ~ multiplicity_properties?
    | multiplicity_properties
}

feature_specialization = {
    typings
    | subsettings
    | references
    | crosses
    | redefinitions
}

// Tokens for feature relationships (matching KerML)
typed_by_token = @{ ":" | ("typed" ~ " " ~ "by") }
subsets_token = @{ ":>" | "subsets" }
references_token = @{ "::>" | "references" }
crosses_token = @{ "=>" | "crosses" }
redefines_token = @{ ":>>" | "redefines" }

// Feature relationship patterns
typings = { typed_by ~ ("," ~ feature_typing)* }

typed_by = { typed_by_token ~ feature_typing }

subsettings = { subsets ~ ("," ~ owned_subsetting)* }

subsets = { subsets_token ~ owned_subsetting }

references = { references_token ~ owned_reference_subsetting }

crosses = { crosses_token ~ owned_cross_subsetting }

redefinitions = { redefines ~ ("," ~ owned_redefinition)* }

redefines = { redefines_token ~ owned_redefinition }

// Feature typing, subsetting, and redefinition
feature_typing = {
    owned_feature_typing
    | conjugated_port_typing
}

// OwnedFeatureTyping inherited from Expression syntax (to be expanded)
owned_feature_typing = { feature_reference }

// Feature subsetting and redefinition rules
owned_subsetting = {
    feature_reference
    | owned_feature_chain
}

owned_reference_subsetting = {
    feature_reference
    | owned_feature_chain
}

owned_cross_subsetting = {
    feature_reference
    | owned_feature_chain
}

owned_redefinition = {
    feature_reference
    | owned_feature_chain
}

// Feature references and chains (matching KerML structure)
feature_reference = { qualified_name | identifier | quoted_name }

owned_feature_chain = { identifier ~ ("." ~ identifier)+ }

// Multiplicity (matching KerML structure)
owned_multiplicity = { "[" ~ multiplicity_range ~ "]" }

multiplicity_range = {
    lower_bound ~ ".." ~ upper_bound
    | bound
}

lower_bound = { number_literal | "*" }
upper_bound = { number_literal | "*" }
bound = { number_literal | "*" }

number_literal = @{ ASCII_DIGIT+ }

multiplicity_properties = {
    "ordered" ~ "nonunique"
    | "nonunique" ~ "ordered"
    | "ordered"
    | "nonunique"
}

// Model Entry Point

model = { SOI ~ namespace_element* ~ EOI }

namespace_element = {
    package
    | library_package
    | import
    | alias_member_element
    | element_filter_member
    | visible_annotating_member
    | usage_member
    | definition_member_element
    | relationship_member_element
    | dependency
}

// Supporting Rules
element_reference = { identifier | quoted_name }
identification = { identifier | quoted_name }
quoted_name = @{ "'" ~ (!("'") ~ ANY)+ ~ "'" }
relationship_body = { ";" | ( "{" ~ relationship_body_elements ~ "}" ) }
relationship_body_elements = { owned_annotation* }
prefix_metadata_annotation = { "#" ~ identifier }

// Annotations

owned_annotation = { annotating_element }

annotating_member = { annotating_element }

annotating_element = {
    comment_annotation
    | documentation
    | textual_representation
    | metadata_usage_annotation
}

comment_annotation = { "comment" ~ identifier ~ ("about" ~ element_reference)? ~ ";" }

documentation = { "doc" ~ (identifier ~ ";")? }

textual_representation = { "rep" ~ "language" ~ quoted_name ~ block_comment? }

metadata_usage_annotation = { "#" ~ identifier ~ ";" }

// Metadata

metadata_definition = {
    abstract_marker?
    ~ prefix_metadata?
    ~ "metadata"
    ~ "def"
    ~ ("<" ~ identifier ~ ">")?
    ~ definition_suffix
}

prefix_metadata_annotation_element = { prefix_metadata_usage }

prefix_metadata_member = { prefix_metadata_usage }

prefix_metadata = { prefix_metadata_member+ }

prefix_metadata_usage = { "#" ~ metadata_typing }

// State-related placeholder rules
guarded_target_succession = { identifier }

metadata_typing = { identifier }

metadata_usage = {
    prefix_metadata?
    ~ ("metadata" | "@")
    ~ metadata_usage_declaration
    ~ ("about" ~ annotation ~ ("," ~ annotation)*)?
    ~ metadata_body
}

metadata_usage_declaration = {
    (identification? ~ defined_by_token)? ~ metadata_typing
}

annotation = { identifier }

metadata_body = { ";" | ( "{" ~ metadata_body_items ~ "}" ) }

metadata_body_items = {
    (definition_member
    | relationship_member
    | visible_annotating_member
    | metadata_body_usage_member
    | metadata_alias_member
    | import)*
}

relationship_member = { identifier ~ ";" }
visible_annotating_member = { annotating_element }
metadata_alias_member = { "alias" ~ identifier ~ "for" ~ identifier ~ ";" }

// Imports

import_prefix = { visibility? ~ "import" ~ import_all? }

import_all = { "all" }

imported_reference = {
    qualified_name
    ~ namespace_marker?
    ~ recursive_marker?
}

qualified_name = { (identifier | quoted_name) ~ ("::" ~ (identifier | quoted_name))* }

namespace_marker = { "::*" }
recursive_marker = { "::**" }

import = {
    import_prefix
    ~ imported_reference
    ~ filter_package?
    ~ relationship_body
}

filter_package = { filter_package_member+ }

filter_package_member = { "[" ~ owned_expression ~ "]" }

metadata_body_usage_member = { metadata_body_usage }

metadata_body_usage = {
    "ref"?
    ~ (redefines_token ~ identifier)?
    ~ feature_specialization_part?
    ~ value_part?
    ~ metadata_body
}

// Dependency

dependency = {
    "dependency"
    ~ ((identification ~ "from") | "from")?
    ~ element_reference ~ ("," ~ element_reference)*
    ~ "to"
    ~ element_reference ~ ("," ~ element_reference)*
    ~ relationship_body
}

// Entry point - will expand as we add rules
file = { SOI ~ WHITESPACE* ~ EOI }
